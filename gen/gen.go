// Package gen is the core of terragen, where the template generation happens.
package gen

import (
	"fmt"
	"html/template"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/nikhilsbhat/neuron/cli/ui"
	"github.com/nikhilsbhat/terragen/decode"
	"github.com/spf13/cobra"
)

// Input holds the required values to generate the templates
type Input struct {
	// The name of the terraform provider you need to start of with.
	Package string
	// List of all the dependent packages for terraform, if not passed it picks default.
	Dependents []string
	// Path defines where the templates has to be generated.
	Path string
	// TemplateRaw consists of go-templates which are the core for terragen.
	TemplateRaw TerraTemplate
	// AutoGenMessage will be configured by terragen and cannot be overwritten.
	AutoGenMessage string
	// Description to be added to resource/datasource
	Description string
	// writer         io.Writer
	template string
}

// TerraTemplate are the collections of go-templates which are used to generate terraform provider's base template.
type TerraTemplate struct {
	// ProviderTemp holds the template for provider
	ProviderTemp string
	// RootTemp holds the template for root file
	RootTemp string
	// DataTemp holds the template for data
	DataTemp string
	// ResourceTemp holds the template for resource
	ResourceTemp string
}

var (
	rootTemp = `{{ .AutoGenMessage }}
package main

import (
	{{- range $index, $element := .Dependents }}
	"{{- $element }}"
	{{- end }}
)

func main() {
	plugin.Serve(&plugin.ServeOpts{
		ProviderFunc: {{ .Package }}.Provider})
}`

	providerTemp = `{{ .AutoGenMessage }}
package {{ .Package }}

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// Provider returns a terraform.ResourceProvider.
func Provider() *schema.Provider {
	return &schema.Provider{
		Schema: map[string]*schema.Schema{},

		ResourcesMap: map[string]*schema.Resource{
			"null_resource": resource{{ .Package | ToUpper }}(),
		},

		DataSourcesMap: map[string]*schema.Resource{
			"null_data_source": dataSource{{ .Package | ToUpper }}(),
		},
	}
}`

	dataSourceTemp = `{{ .AutoGenMessage }}
package {{ .Package }}

import (
    "context"
    "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSource{{ .Package | ToUpper }}() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSource{{ .Package | ToUpper }}Read,

		Schema: map[string]*schema.Schema{},
	}
}

func dataSource{{ .Package | ToUpper }}Read(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	// Your code goes here
	return nil
}`

	resourceTemp = `{{ .AutoGenMessage }}
package {{ .Package }}

import (
    "context"
    "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resource{{ .Package | ToUpper }}() *schema.Resource {
	return &schema.Resource{
		CreateContext: resource{{ .Package | ToUpper }}Create,
		ReadContext:   resource{{ .Package | ToUpper }}Read,
		DeleteContext: resource{{ .Package | ToUpper }}Delete,

		Schema: map[string]*schema.Schema{},
	}
}

func resource{{ .Package | ToUpper }}Create(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics  {
	// Your code goes here
	return nil
}

func resource{{ .Package | ToUpper }}Read(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics  {
	// Your code goes here
	return nil
}

func resource{{ .Package | ToUpper }}Delete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics  {
	// Your code goes here
	return nil
}`

	autoGenMessage = `// ----------------------------------------------------------------------------
//
//     ***     TERRAGEN GENERATED CODE    ***    TERRAGEN GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file was auto generated by Terragen.
//     This autogenerated code has to be enhanced further to make it fully working terraform-provider.
//
//     Get more information on how terragen works.
//     https://github.com/nikhilsbhat/terragen
//
// ----------------------------------------------------------------------------`
)

// Generate generates the basic folder/files templates to build terraform custom provider.
func (i *Input) Generate(cmd *cobra.Command, args []string) {
	i.getTemplate()
	i.Path = i.getPath()
	i.template = fmt.Sprintf("terraform-provider-%s", i.Package)
	i.AutoGenMessage = autoGenMessage
	if i.providerExists() {
		fmt.Println(ui.Error(fmt.Sprintf("looks like scaffold %s with the same name was created earlier in the location %s\n",
			i.template, i.Path)))
		os.Exit(1)
	}

	if i.Dependents == nil {
		i.Dependents = []string{fmt.Sprintf("%s/%s", i.template, i.Package), "github.com/hashicorp/terraform-plugin-sdk/v2/plugin"}
	}

	// Generating the base terraform provider folder ex: terraform-provider-demo
	fmt.Println(ui.Info(fmt.Sprintf("\nscaffold will be generated under %s\n", i.Path)))
	if err := i.genTerraDir(); err != nil {
		fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
		os.Exit(1)
	}

	// Generating the required files
	var files = map[string]string{
		"main.go":        i.Path,
		"provider.go":    fmt.Sprintf("%s/%s", i.Path, i.Package),
		"data_source.go": fmt.Sprintf("%s/%s", i.Path, i.Package),
		"resource.go":    fmt.Sprintf("%s/%s", i.Path, i.Package),
	}

	for key, value := range files {
		if err := i.genTerraFiles(key, value); err != nil {
			fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
			os.Exit(1)
		}
	}

	// Setup the project to make it ready for developable
	fmt.Println(ui.Info("terragen is in the process of making life simpler\n"))
	if err := i.setupTerragen(); err != nil {
		fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
		os.Exit(1)
	}

	if err := i.createMakefile(i.template); err != nil {
		fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
		os.Exit(1)
	}
	fmt.Println(ui.Info("life is less complicated now ...!!\n"))
	fmt.Println(ui.Info("start enhancing the code from the scaffold generated by terragen\n"))
}

func (i *Input) getPath() string {
	if i.Path == "." {
		dir, err := os.Getwd()
		if err != nil {
			fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
			os.Exit(1)
		}
		return dir
	}
	return path.Dir(i.Path)
}

func (i *Input) genTerraDir() error {
	pathTgen := filepath.Join(i.Path, i.template)
	fmt.Println(ui.Info(fmt.Sprintf("template %s does not exists, generating one for you\n", i.template)))
	err := os.MkdirAll(path.Join(pathTgen, i.Package), 0777)
	if err != nil {
		return err
	}
	i.Path = pathTgen
	return nil
}

func (i *Input) genTerraFiles(name, path string) error {
	file, err := os.Create(filepath.Join(path, name))
	if err != nil {
		return err
	}
	defer file.Close()

	funcMap := template.FuncMap{
		"ToUpper": strings.ToUpper,
	}

	var tmpl *template.Template
	switch name {
	case "main.go":
		if len(i.TemplateRaw.RootTemp) != 0 {
			tmpl = template.Must(template.New(name).Parse(i.TemplateRaw.RootTemp))
			if err := tmpl.Execute(file, i); err != nil {
				return err
			}
			return nil
		}
		return fmt.Errorf("template not found for main.go")
	case "provider.go":
		if len(i.TemplateRaw.ProviderTemp) != 0 {
			tmpl = template.Must(template.New(name).Funcs(funcMap).Parse(i.TemplateRaw.ProviderTemp))
			if err := tmpl.Execute(file, i); err != nil {
				return err
			}
			return nil
		}
		return fmt.Errorf("template not found for provider.go")
	case "data_source.go":
		if len(i.TemplateRaw.DataTemp) != 0 {
			tmpl = template.Must(template.New(name).Funcs(funcMap).Parse(i.TemplateRaw.DataTemp))
			if err := tmpl.Execute(file, i); err != nil {
				return err
			}
			return nil
		}
		return fmt.Errorf("template not found for data_source.go")
	case "resource.go":
		if len(i.TemplateRaw.ResourceTemp) != 0 {
			tmpl = template.Must(template.New(name).Funcs(funcMap).Parse(i.TemplateRaw.ResourceTemp))
			if err := tmpl.Execute(file, i); err != nil {
				return err
			}
			return nil
		}
		return fmt.Errorf("template not found for resource.go")
	}
	return fmt.Errorf("snap.....!! Unable to render the templates, looks like they have issues")
}

func (i *Input) setupTerragen() error {
	goInit := exec.Command("go", "mod", "init", i.template) //nolint:gosec
	goInit.Dir = i.Path
	if err := goInit.Run(); err != nil {
		return err
	}

	goFmt := exec.Command("goimports", "-w", i.Path) //nolint:gosec
	goFmt.Dir = i.Path
	if err := goFmt.Run(); err != nil {
		return err
	}

	goVnd := exec.Command("go", "mod", "vendor") //nolint:gosec
	goVnd.Dir = i.Path
	if err := goVnd.Run(); err != nil {
		return err
	}
	return nil

}

// Set the templates to defaults if not specified.
func (i *Input) getTemplate() {
	if reflect.DeepEqual(i.TemplateRaw, TerraTemplate{}) {
		i.TemplateRaw.RootTemp = rootTemp
		i.TemplateRaw.ProviderTemp = providerTemp
		i.TemplateRaw.DataTemp = dataSourceTemp
		i.TemplateRaw.ResourceTemp = resourceTemp
	}
}

func (i *Input) providerExists() bool {
	pathTgen := filepath.Join(i.Path, i.template)
	if _, direrr := os.Stat(pathTgen); os.IsNotExist(direrr) {
		return false
	}
	return true
}
