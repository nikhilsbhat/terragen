// Package gen is the core of terragen, where the template generation happens.
package gen

import (
	"fmt"
	"html/template"
	"io"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/nikhilsbhat/neuron/cli/ui"
	"github.com/nikhilsbhat/terragen/decode"
	"github.com/spf13/cobra"
)

//GenInput holds the required values to generate the templates
type GenInput struct {
	// The name of the terraform provider you need to start of with.
	Package string
	// List of all the dependent packages for terraform, if not passed it picks default.
	Dependents []string
	// Path defines where the templates has to be generated.
	Path string
	// TemplateRaw consists of go-templates which are the core for terragen.
	TemplateRaw    TerraTemplate
	writer         io.Writer
	template       string
	AutoGenMessage string
}

// TerraTemplate are the collections of go-templates which are used to generate terraform provider's base template.
type TerraTemplate struct {
	ProviderTemp string
	RootTemp     string
	DataTemp     string
	ResourceTemp string
}

var rootTemp = `{{ .AutoGenMessage }}
package main

import (
	{{- range $index, $element := .Dependents }}
	"{{- $element }}"
	{{- end }}
)

func main() {
	plugin.Serve(&plugin.ServeOpts{
		ProviderFunc: {{ .Package }}.Provider})
}`

var providerTemp = `{{ .AutoGenMessage }}
package {{ .Package }}

import (
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
)

// Provider returns a terraform.ResourceProvider.
func Provider() terraform.ResourceProvider {
	return &schema.Provider{
		Schema: map[string]*schema.Schema{},

		ResourcesMap: map[string]*schema.Resource{
			"null_resource": resource{{ .Package | ToUpper }}(),
		},

		DataSourcesMap: map[string]*schema.Resource{
			"null_data_source": dataSource{{ .Package | ToUpper }}(),
		},
	}
}`

var dataSourceTemp = `{{ .AutoGenMessage }}
package {{ .Package }}

import (
	"github.com/hashicorp/terraform/helper/schema"
)

func dataSource{{ .Package | ToUpper }}() *schema.Resource {
	return &schema.Resource{
		Read: dataSource{{ .Package | ToUpper }}Read,

		Schema: map[string]*schema.Schema{},
	}
}

func dataSource{{ .Package | ToUpper }}Read(d *schema.ResourceData, meta interface{}) error {
	// Your code goes here
	return nil
}`

var resourceTemp = `{{ .AutoGenMessage }}
package {{ .Package }}

import (
	"github.com/hashicorp/terraform/helper/schema"
)

func resource{{ .Package | ToUpper }}() *schema.Resource {
	return &schema.Resource{
		Create: resource{{ .Package | ToUpper }}Create,
		Read:   resource{{ .Package | ToUpper }}Read,
		Delete: resource{{ .Package | ToUpper }}Delete,

		Schema: map[string]*schema.Schema{},
	}
}

func resource{{ .Package | ToUpper }}Create(d *schema.ResourceData, meta interface{}) error {
	// Your code goes here
	return nil
}

func resource{{ .Package | ToUpper }}Read(d *schema.ResourceData, meta interface{}) error {
	// Your code goes here
	return nil
}

func resource{{ .Package | ToUpper }}Delete(d *schema.ResourceData, meta interface{}) error {
	// Your code goes here
	return nil
}`

var autoGenMessage = `// ----------------------------------------------------------------------------
//
//     ***     TERRAGEN GENERATED CODE    ***    TERRAGEN GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file was generated automatically by Terragen.
//     This autogenerated code has to be enhanced further to make it fully working terraform-provider.
//
//     Get more information on how terragen works.
//     https://github.com/nikhilsbhat/terragen
//
// ----------------------------------------------------------------------------`

// Generate generates the basic folder/files templates to build terraform custom provider.
func (i *GenInput) Generate(cmd *cobra.Command, args []string) {

	i.getTemplate()
	i.Path = i.getPath()
	i.template = fmt.Sprintf("terraform-provider-%s", i.Package)
	i.AutoGenMessage = autoGenMessage
	if i.providerExists() {
		fmt.Println(ui.Error(fmt.Sprintf("Looks like template %s was created earlier in the location %s\n", i.template, i.Path)))
		os.Exit(1)
	}

	if i.Dependents == nil {
		i.Dependents = []string{fmt.Sprintf("%s/%s", i.template, i.Package), "github.com/hashicorp/terraform/plugin"}
	}

	// Generating the base terraform provider folder ex: terraform-provider-demo
	fmt.Println(ui.Info(fmt.Sprintf("\nTemplates will be generated under %s\n", i.Path)))
	if err := i.genTerraDir(); err != nil {
		fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
		os.Exit(1)
	}

	// Generating the required files
	var files = map[string]string{
		"main.go":        i.Path,
		"provider.go":    fmt.Sprintf("%s/%s", i.Path, i.Package),
		"data_source.go": fmt.Sprintf("%s/%s", i.Path, i.Package),
		"resource.go":    fmt.Sprintf("%s/%s", i.Path, i.Package),
	}

	for key, value := range files {
		if err := i.genTerraFiles(key, value); err != nil {
			fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
			os.Exit(1)
		}
	}

	// Setup the project to make it ready for developable
	fmt.Println(ui.Info("terragen is in the process of making provider creator's life easy\n"))
	if err := i.setupTerragen(); err != nil {
		fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
		os.Exit(1)
	}
	fmt.Println(ui.Info("life of provider creator is less complicated now ...!!\nStart enhancing the code from the templates generated by terragen\n"))
}

func (i *GenInput) getPath() string {
	if i.Path == "." {
		dir, err := os.Getwd()
		if err != nil {
			fmt.Println(ui.Error(decode.GetStringOfMessage(err)))
			os.Exit(1)
		}
		return dir
	}
	return path.Dir(i.Path)
}

func (i *GenInput) genTerraDir() error {
	pathTgen := filepath.Join(i.Path, i.template)
	/*if _, direrr := os.Stat(pathTgen); os.IsNotExist(direrr) {
		fmt.Println(ui.Info(fmt.Sprintf("template %s does not exists, generating one for you\n", i.template)))
		err := os.MkdirAll(path.Join(pathTgen, i.Package), 0777)
		if err != nil {
			return err
		}
		i.Path = pathTgen
		return nil
	}*/
	fmt.Println(ui.Info(fmt.Sprintf("template %s does not exists, generating one for you\n", i.template)))
	err := os.MkdirAll(path.Join(pathTgen, i.Package), 0777)
	if err != nil {
		return err
	}
	i.Path = pathTgen
	return nil
}

func (i *GenInput) genTerraFiles(name, path string) error {
	file, err := os.Create(filepath.Join(path, name))
	if err != nil {
		return err
	}
	defer file.Close()
	funcMap := template.FuncMap{
		"ToUpper": strings.ToUpper,
	}

	var tmpl *template.Template
	switch name {
	case "main.go":
		if len(i.TemplateRaw.RootTemp) != 0 {
			tmpl = template.Must(template.New(name).Parse(i.TemplateRaw.RootTemp))
			tmpl.Execute(file, i)
			return nil
		}
		return fmt.Errorf("Template not found for main.go")
	case "provider.go":
		if len(i.TemplateRaw.ProviderTemp) != 0 {
			tmpl = template.Must(template.New(name).Funcs(funcMap).Parse(i.TemplateRaw.ProviderTemp))
			tmpl.Execute(file, i)
			return nil
		}
		return fmt.Errorf("Template not found for provider.go")
	case "data_source.go":
		if len(i.TemplateRaw.DataTemp) != 0 {
			tmpl = template.Must(template.New(name).Funcs(funcMap).Parse(i.TemplateRaw.DataTemp))
			tmpl.Execute(file, i)
			return nil
		}
		return fmt.Errorf("Template not found for data_source.go")
	case "resource.go":
		if len(i.TemplateRaw.ResourceTemp) != 0 {
			tmpl = template.Must(template.New(name).Funcs(funcMap).Parse(i.TemplateRaw.ResourceTemp))
			tmpl.Execute(file, i)
			return nil
		}
		return fmt.Errorf("Template not found for resource.go")
	}
	return fmt.Errorf("Snap.....!! templates has issue unable to render")
}

func (i *GenInput) setupTerragen() error {
	goInit := exec.Command("go", "mod", "init", i.template)
	goInit.Dir = i.Path
	if err := goInit.Run(); err != nil {
		return err
	}

	goVnd := exec.Command("go", "mod", "vendor")
	goVnd.Dir = i.Path
	if err := goVnd.Run(); err != nil {
		return err
	}
	return nil
}

// Set the templates to defaults if not specified.
func (i *GenInput) getTemplate() {
	if reflect.DeepEqual(i.TemplateRaw, TerraTemplate{}) {
		//temp := new(TerraTemplate)
		i.TemplateRaw.RootTemp = rootTemp
		i.TemplateRaw.ProviderTemp = providerTemp
		i.TemplateRaw.DataTemp = dataSourceTemp
		i.TemplateRaw.ResourceTemp = resourceTemp
	}
}

func (i *GenInput) providerExists() bool {
	pathTgen := filepath.Join(i.Path, i.template)
	if _, direrr := os.Stat(pathTgen); os.IsNotExist(direrr) {
		return false
	}
	return true
}
